{
  "hash": "ce4c7d5fc29fa50c5b3b57d105784360",
  "result": {
    "markdown": "# R Basics {#sec-rbasics}\n\n\n```{mermaid}\nflowchart LR\nO[Objects] --> N[Numeric] --> Nt[integer<br>floating point]\nO --> NN[Non-Numeric] --> log[logical] & ch[character] & F[function]\nO --> Sh[Shape] --> Shs[scalar<br>vector<br>matrix<br>array]\nSh --> Li[list]\nLi --> df[data.frame] & dt[data.table] & it[irregular tree]\nO --> Ad[\"Addressing<br>(subscripts)\"] --> sub[integer<br>logical<br>names]\nO --> SV[Special Values] --> na[NA]\nF --> cf[Common Functions<br>Write Your Own]\nDec[Decisions] --> btypes[if<br>ifelse<br>switch]\n```\n\n\n## Assignment Operator\n\nYou assign an R object to a value using the assignment operator `<-` or the equal sign.  `<-` is read as \"gets\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- y\nd <- read.csv('mydata.csv')\nx = y\n```\n:::\n\n\n## Object Types {#sec-rbasics-objects}\n\nEverything in R is an object.  Some primitive types of objects in R are below.\n\n| Type | Meaning |\n|------|---------|\n| integer | whole numbers |\n| logical | values of `TRUE` or `FALSE` |\n| double  | floating point non-whole numbers |\n| character | character strings |\n| function| code defining a function |\n\nIn the table below, objects of different shapes are described.\n`rows` and `cols` refers to vectors of integers or logicals, or if the elements of the object are named, character strings.\n\n| Type | Example |Values Retrieved By|\n|------|---------|--------------------|\n| scalar |  `x <- 3` | `x` |\n| vector | `y <- c(1, 2, 5)` | `y[2]` (2), `y[2:3]` (2, 5), `y[-1]` (2, 5), `y[c(TRUE,FALSE,TRUE)]` (1, 5) |\n| named vector | `y <- c(a=1, b=2, d=5)` | `y[2]` (2), `y['b']` (2), `y[c('a','b')]` (1, 2) |\n| matrix | `y <- cbind(1:3, 4:5)` | `y[rows,cols]`, `y[rows,]` (all cols), `y[,cols]` (all rows) |\n| array  | `y <- array(1:30, dim=c(2,3,5))` | `y[1,1,1]` (1), `y[2,3,5]` (30) |\n| list | `x <- list(a='cat', b=c(1,3,7))` | `x$a` ('cat'), `x[[1]]` ('cat'), `x[['a']]` ('cat') |\n\nNamed vectors provide an extremely quick table lookup and recoding capability.\n\n`list` objects are arbitrary trees and can have elements nested to any level.  You can have lists of lists or lists of data frames/tables.\n\nVectors can be of many different types when a `class` is added to them.  Two of the most common are `Date`s and `factor`s.  Character strings are handled very efficiently in R so there is not always a need to store categorical variables as `factor`s.  But there is one reason: to order levels, i.e., distinct variable values, so that tabular and graphical output will list values in a more logical order than alphabetic.  A factor variable has a `levels` _attribute_ added to it to accomplish this.  An example is `x <- factor(x, 1:3, c('cat', 'dog', 'fox'))` where the second argument `1:3` is the vector of possible numeric values `x` currently takes on (in order) and the three character strings are the corresponding `levels`.  Internally `factors` are coded as integers, but they print as character strings.\n\nRectangular data objects, i.e., when the number of rows is the same for every column (variable), can be represented by matrices, arrays, `data.frame`s, and `data.table`s.  In a matrix or array, every value is of the same type.  A `data.frame` or a `data.table` is an R `list` that can have mixtures of numeric, character, factor, dates, and other object types.  A `data.table` is also a `data.frame` but the converse isn't true.  `data.table`s are handled by the R `data.table` package and don't have row names but can be indexed, are much faster to process, and have a host of methods implemented for aggregation and other operations.  `data.frame`s are handled by base R.[See @sec-sim-array for an example of using arrays with named elements]{.aside}\n\nData frames are best managed by converting them to data tables and using the `data.table` package.  When `data.table` is not used there are three indispensable functions for operating on data frames:\n\n* `with` for analyzing variables within a data frame without constantly prefixing variable names with `dataframename$`\n* `transform` for adding or changing variables within a data frame\n* `Hmisc` `upData` function for doing the same as `transform` but also allowing metadata to be added to the data, e.g., variable labels and units (to be discussed later)\n\nHere are some examples of `with` and `transform`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Better than mean(mydata$systolic.bp - mydata$diastolic.bp) :\nwith(mydata, mean(systolic.bp - diastolic.bp))\n# Better than mydata$pulse.pressure <- mydata$systolic.bp - mydata$diastolic.bp:\nmydata <- transform(mydata,\n                    pulse.pressure = systolic.bp - diastolic.bp,\n                    bmi            = wt / ht ^ 2)\n# Perform several operations on the same data frame\nwith(mydata, {\n               x3 <- x1 / sqrt(x2)\n               ols(y ~ x3)\n             }  )\n```\n:::\n\n\n## Missing Values {#sec-rbasics-na}\n\nR objects of any type can have elements whose values are missing.  The symbol R uses for a missing value is `NA`.  The `is.na` function returns `TRUE/FALSE` according to whether an element is missing.  The following examples illustrate operations on `NA`s.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, NA, 4, 5, NA)\nmean(x)              # mean of all x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nmean(x, na.rm=TRUE)  # mean of non-missing x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nis.na(x)             # vector corresponding to x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE FALSE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\nsum(is.na(x))        # count # NAs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\ntable(is.na(x))      # count # NAs and non-NAs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nFALSE  TRUE \n    4     2 \n```\n:::\n\n```{.r .cell-code}\nx[! is.na(x)]        # get the non-missing x's\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 4 5\n```\n:::\n\n```{.r .cell-code}\nx[1] <- NA           # make x[1] missing\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA  2 NA  4  5 NA\n```\n:::\n\n```{.r .cell-code}\ny <- letters[1:6]    # first 6 lower case letters of alphabet\ny[is.na(x)]          # get y for which x is NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"c\" \"f\"\n```\n:::\n:::\n\n\nAs seen in the examples, most simple statistical summarization functions such as `mean` will result in `NA` if any element is `NA`, and you have to specify an optional argument `na.rm=TRUE` to remove `NA`s before computing so that the result will be, for example, the mean of the non-missing values.\n\n## Subscripting\n\nExamples of subscripting are given above. \nSubscripting via placement of `[]` after an object name is used for subsetting, and occasionally for using some elements more than once:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c('cat', 'dog', 'fox')\nx[2:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dog\" \"fox\"\n```\n:::\n\n```{.r .cell-code}\nx[c(1, 1, 3, 3, 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"cat\" \"cat\" \"fox\" \"fox\" \"dog\"\n```\n:::\n:::\n\n\nSubscripting a variable or a data frame/table by a vector of `TRUE/FALSE` values is a very powerful feature of R.  This is used to obtain elements satisfying one or more conditions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3, 2, 1, 4, 7)\ny <- c(1, 8, 2, 3, 8, 9, 2)\nx[y > 7]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 1 4\n```\n:::\n:::\n\n\nThe last line of code can be read as \"values of `x` such that `y > 7`\".\n\n## Branching and If/Then\n\n### Decisions Based on One Scalar Value\n\nCommon approaches to this problem are `if` and `switch`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntype <- 'semiparametric'\nf <- switch(type,\n            parametric     = ols(y ~ x),\n            semiparametric = orm(y ~ x),\n            nonparametric  = rcorr(x, y, type='spearman'),\n            { z <- y / x\n              c(median=median(z), gmean=exp(mean(log(z)))) } )\n# The last 2 lines are executed for any type other than the 3 listed\nf <- if(type == 'parametric')    ols(y ~ x)\n  else\n    if(type == 'semiparametric') orm(y ~ x)\n  else\n    if(type == 'nonparametric')  rcorr(x, y, type='spearman')\n  else {\n    z <- y / z\n    c(median=median(z), gmean=exp(mean(log(z)))\n  }\n```\n:::\n\n\nWhat is inside `if( )` must be a single scalar element that is evaluated to whether it's `TRUE` or `FALSE`.\n\n### Series of Separate Decisions Over a Vector of Values\n\nThe `ifelse` or `data.table::fifelse` functions are most often used for this, but `data.table::fcase` is a little better.  Here's an example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c('cat', 'dog', 'giraffe', 'elephant')\ntype <- ifelse(x %in% c('cat', 'dog'), 'domestic', 'wild')\ntype\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"domestic\" \"domestic\" \"wild\"     \"wild\"    \n```\n:::\n\n```{.r .cell-code}\nrequire(data.table)\nfcase(x %in% c('cat', 'dog'), 'domestic', default='wild')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"domestic\" \"domestic\" \"wild\"     \"wild\"    \n```\n:::\n:::\n\n\n### `if` Trick\n\nSometimes when constructing variable-length vectors and other objects, elements are to be included in the newly constructed object only when certain conditions apply.  When a condition does not apply, no element is to be inserted.  We can capitalize on the fact that the result of `if(...)` is `NULL` when `...` is not `TRUE`, and concatenating `NULL` results in ignoring it.  Here are two examples.  In the first the resulting vector will have length 2, 3, or 4 depending on `sex` and `height`.  In the second example the new vector will have the appropriate element `names` preserved.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 23; z <- 46; sex <- 'female'; height <- 71; u <- pi; w <- 7\nc(y, z, if(sex == 'male') u, if(height > 70) w)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 23 46  7\n```\n:::\n\n```{.r .cell-code}\nc(x1=3, if(sex == 'male') c(x2=4), if(height > 70) c(x3=height))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx1 x3 \n 3 71 \n```\n:::\n\n```{.r .cell-code}\n# reduce clutter in case of variable name conflicts:\nrm(y, z, sex, height, u, w)\n```\n:::\n\n\n## Functions {#sec-rbasics-functions}\n\nThere are so many functions in R that it may be better to use the [stackoverflow.com](https://stackoverflow.com/questions/tagged/r) Q&A to find the ones you need (as of 2022-05-26 there are 450,000 R questions there).  Here are just a few of the multitude of handy R functions.  The first functions listed below return the R missing value `NA` if any element is missing.  You can specify `na.rm=TRUE` to remove `NA`s from consideration first, so they will not cause the result to be `NA`.  Most functions get their arguments (inputs) in () after the function name.  Some functions like `%in%` are binary operators whose two arguments are given on the left and right of `%in%`.\n\n* `mean`, `median`, `quantile`, `var`, `sd`: Compute statistical summaries on one vector\n* `min, max`: Minimum or maximum of values in a vector or of multiple variables, resulting in one number\n* `pmin, pmax`: Parallel minimum and maximum for vectors, resulting in a vector.  Example: `pmin(x, 3)` returns a vector of the same length as `x`.  Each element is the minimum of the original value or 3.\n* `range`: Returns a vector of length two with the minimum and maximum\n* `plot`, `points`, `lines`, `text`: Basic ploting functions\n* `table`: Frequency tabulation and multi-way tabulations of any type of vector variables\n* `unique`: Return vector of distinct values, in same order as original values\n* `union`, `intersect`, `setdiff`, `setequal`: Set operations on two vectors (see below)\n* `a %in% b`, `a %nin% b`: Set membership functions that determine whether each element in `a` is in `b` (for `%in%`) or is not in `b` (for `%nin%`, which is in the `Hmisc` package)\n\nSet operators are amazingly helpful.  Here are some examples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(x)       # vector of distinct values of x, including NA if occurred\nsort(unique(x)) # distinct values in ascending order\nsetdiff(unique(x), NA)  # distinct values excluding NA if it occurred\nduplicated(x)   # returns TRUE for elements that are duplicated by\n                # values occurring EARLIER in the list\nunion(x, y)     # find all distinct values in the union of x & y\nintersect(x, y) # find all distinct values in both x & y\nsetdiff(x, y)   # find all distinct x that are not in y\nsetequal(x, y)  # returns TRUE or FALSE depending on whether the distinct\n                # values of x and y are identical, ignoring how they\n                # are ordered\n```\n:::\n\n\nFind a list of subject ids that are found in baseline but not in follow-up datasets:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidn <- setdiff(baseline$id, followup$id)\n```\n:::\n\n\nAvoid repetition: Don't say `if(animal == 'cat' | animal == 'dog') ....`; use `%in%` instead:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif(animal %in% c('cat', 'dog')) ...\n# or if(animal %in% .q(cat, dog)) ... using Hmisc's .q\n```\n:::\n\n\nLikewise don't say `if(animal != 'cat' & animal != 'dog')` but use `if(animal %nin% c('cat', 'dog')) ...`\n\nTo get documentation on a function type the following in the R console: `?functionname` or `?packagename::functionname`.\n\nEven new R users can benefit from writing functions to reduce repetitive coding.  A function has _arguments_ and these can have default values for when the argument is not specified by the user when the function is called.  Here are some examples.  One line functions do not need to have their bodies enclosed in `{}`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncuberoot <- function(x) x ^ (1/3)\ncuberoot(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\ng <- function(x, power=2) {\n  u <- abs(x - 0.5)\n  u / (1. + u ^ power)\n}\ng(3, power=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3448276\n```\n:::\n\n```{.r .cell-code}\ng(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3448276\n```\n:::\n:::\n\n\nWrite a function make `mean()` drop missing values without our telling it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmn <- function(x) mean(x, na.rm=TRUE)\n```\n:::\n\n\nFunction to be used throughout the report to round fractional values by a default amount (here round to 0.001):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnd <- function(x) round(x, 3)\n# edit the 3 the change rounding anywhere in the report\n```\n:::\n\n\nA simple function to save coding when you need to recode multiple\nvariables from 0/1 to no/yes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyn <- function(x) factor(x, 0:1, c('no', 'yes'))\n```\n:::\n\n\n## Resources for Learning R\n\n* [Fast Lane to Learning R](https://github.com//matloff/fasteR)\n* [R Tutorials](https://r-bloggers.com/how-to-learn-r-2)\n* [R Programming Tutorials](https://youtube.com/user/marinstatlectures)\n* [Swirlstats](https://swirlstats.com) (interactive)\n* For [those who have used SPSS or SAS before](https://www.amazon.com/SAS-SPSS-Users-Statistics-Computing/dp/1461406846)\n* [R books on Amazon](http://amzn.to/15URiF6)\n* [UCLA site](https://stats.idre.ucla.edu/r)\n* [R Resources for Beginners](http://www.introductoryr.co.uk/R_Resources_for_Beginners.html)\n* [R for Data Science](https://r4ds.had.co.nz)\n* [R in Action](https://www.amazon.com/R-Action-Robert-Kabacoff/dp/1935182)\n* [Statistical modeling by Legler and Roback](https://bookdown.org/roback/bookdown-bysh)\n* [stackoverflow.com/tags/r](http://stackoverflow.com/tags/r) is the best place for asking questions about the language and for learning from answers to past questions asked",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}